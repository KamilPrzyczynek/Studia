# -*- coding: utf-8 -*-
"""lab1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kO3CaD89Wjkhwu6hNs2DIm7TFB67cAx5
"""

from google.colab import drive
drive.mount('/content/drive')

# prompt: napisz prostą grę w zgadywanie liczby w 7 próbach

import random

def gra_w_zgadywanie():
  liczba = random.randint(1, 100)
  proba = 0

  print("Zgadnij liczbę z zakresu od 1 do 100. Masz 7 prób.")

  while proba < 7:
    proba += 1
    try:
      zgadywana_liczba = int(input(f"Próba {proba}: "))
    except ValueError:
      print("Podaj liczbę całkowitą!")
      proba -= 1  # Nie licz nieprawidłowej próby
      continue

    if zgadywana_liczba < liczba:
      print("Za mało!")
    elif zgadywana_liczba > liczba:
      print("Za dużo!")
    else:
      print(f"Brawo! Zgadłeś liczbę {liczba} w {proba} próbach!")
      return

  print(f"Przegrałeś! Liczba to {liczba}.")

gra_w_zgadywanie()

"""3 Symboliczna sztuczna inteligencja
3.1 Instrukcje warunkowe Zadaniem jakie w pierwszej kolejności wykonamy jest budowa prostego systemu diagnostycznego w oparciu o instrukcje warunkowe. Zadanie rozpoczniemy od narysowania diagramu przedstawiającego różne możliwe przypadki. System ma pobrać od pacjenta informacje o stanie zdrowia. Badaniu podlegają 4 objawy: gorączka, kaszel, ból głowy oraz zmęczenie.
"""

from graphviz import Digraph
from IPython.display import display

# Tworzenie drzewa decyzyjnego
dot = Digraph()

# Dodanie węzłów drzewa decyzyjnego
dot.node('A', 'Gorączka?')
dot.node('B', 'Kaszel?')
dot.node('B2', 'Kaszel?')
dot.node('C', 'Ból głowy?')
dot.node('C2', 'Ból głowy?')
dot.node('D', 'Zmęczenie?')
dot.node('D2', 'Zmęczenie?')
dot.node('D3', 'Zmęczenie?')
dot.node('E', 'Możliwe zapalenie płuc', shape='box')
dot.node('F', 'Możliwa grypa', shape='box')
dot.node('G', 'Możliwe przeziębienie', shape='box')
dot.node('H', 'Możliwe COVID-19', shape='box')
dot.node('I', 'Możliwe zmęczenie lub stres', shape='box')
dot.node('J', 'Brak widocznych objawów choroby', shape='box')
dot.node('K', 'Brak diagnozy', shape='box')

# Łączenie węzłów (warunki decyzyjne)
dot.edge('A', 'B', label='Tak')   # Gorączka -> Kaszel
dot.edge('A', 'B2', label='Nie')   # Gorączka -> Kaszel
dot.edge('B', 'C', label='Tak')    # Kaszel -> Ból głowy
dot.edge('B', 'D', label='Nie')    # Kaszel -> Zmęczenie
dot.edge('C', 'E', label='Tak')    # Ból głowy -> Możliwe zapalenie płuc
dot.edge('C', 'F', label='Nie')    # Ból głowy -> Możliwa grypa
dot.edge('B2', 'D2', label='Tak')  # Kaszel -> Zmęczenie
dot.edge('B2', 'C2', label='Nie')  # Kaszel -> Ból głowy
dot.edge('D2', 'G', label='Tak')   # Zmęczenie -> Możliwe przeziębienie
dot.edge('D2', 'K', label='Nie')   # Zmęczenie -> Brak diagnozy
dot.edge('D', 'H', label='Tak')    # Zmęczenie -> Możliwe COVID-19
dot.edge('D', 'K', label='Nie')    # Zmęczenie -> Brak diagnozy
dot.edge('C2', 'K', label='Tak')   # Ból głowy -> Brak diagnozy
dot.edge('C2', 'D3', label='Nie')  # Ból głowy -> Zmęczenie
dot.edge('D3', 'I', label='Tak')   # Zmęczenie -> Możliwe zmęczenie lub stres
dot.edge('D3', 'J', label='Nie')   # Zmęczenie -> Brak widocznych objawów choroby

# Wyświetlenie drzewa
display(dot)

# Parametry formularza do zbierania danych wejściowych od użytkownika
goraczka = False  # @param {type:"boolean"}
kaszel = True    # @param {type:"boolean"}
bol_glowy = False  # @param {type:"boolean"}
zmeczenie = True  # @param {type:"boolean"}

# Funkcja do diagnozy na podstawie reguł
def diagnoza(goraczka, kaszel, bol_glowy, zmeczenie):
    wynik = 'Brak diagnozy'
    # Baza wiedzy: Reguły diagnozy oparte na objawach
    reguly = [
        {'warunek': lambda g, k, b, z: g and k and b, 'dzialanie': 'Mozliwe zapalenie pluc'},
        {'warunek': lambda g, k, b, z: g and k and not b, 'dzialanie': 'Mozliwe grypa'},
        {'warunek': lambda g, k, b, z: not g and k and z, 'dzialanie': 'Mozliwe przeziebienie'},
        {'warunek': lambda g, k, b, z: g and not k and z, 'dzialanie': 'Mozliwe COVID-19'},
        {'warunek': lambda g, k, b, z: not g and not k and not b and z, 'dzialanie': 'Mozliwe zmeczenie lub stres'},
        {'warunek': lambda g, k, b, z: not g and not k and not b and not z, 'dzialanie': 'Brak widocznych objawow choroby'}
    ]
    # Dopasowanie do reguł
    for regula in reguly:
        if regula['warunek'](goraczka, kaszel, bol_glowy, zmeczenie):
            wynik = regula['dzialanie']
            break
    return wynik

# Funkcja do przetwarzania wyników
def przetworz_wyniki():
    wynik_diag = diagnoza(goraczka, kaszel, bol_glowy, zmeczenie)
    print(f"Na podstawie wprowadzonych objawow, diagnoza: {wynik_diag}")

# Uruchomienie procesu
przetworz_wyniki()

"""3.2 Sieci semantyczne"""

from graphviz import Digraph
from IPython.display import display

net = Digraph()

# Dodanie węzłów
net.node("A", "Gołąb")
net.node("B", "Cechy")
net.node("C", "Zachowanie")
net.node("D", "Środowisko")
net.node("E", "Znaczenie dla ludzi")

# Cechy gołębia
net.node("B1", "Ptak")
net.node("B2", "Latający")
net.node("B3", "Pióra")
net.node("B4", "Dziób")
net.node("B5", "Szare ubarwienie")

# Zachowanie
net.node("C1", "Żerowanie")
net.node("C2", "Gromadzenie się w stadach")
net.node("C3", "Orientacja w przestrzeni")
net.node("C4", "Budowanie gniazd")

# Środowisko
net.node("D1", "Miejskie")
net.node("D2", "Wiejskie")
net.node("D3", "Skalne klify")
net.node("D4", "Parki i place")

# Znaczenie dla ludzi
net.node("E1", "Symbol pokoju")
net.node("E2", "Gołębie pocztowe")
net.node("E3", "Obiekt badań naukowych")
net.node("E4", "Problem w miastach")

# Łączenie węzłów
net.edge("A", "B", label="Posiada")
net.edge("A", "C", label="Wykazuje")
net.edge("A", "D", label="Zamieszkuje")
net.edge("A", "E", label="Ma znaczenie dla ludzi")

net.edge("B", "B1")
net.edge("B", "B2")
net.edge("B", "B3")
net.edge("B", "B4")
net.edge("B", "B5")

net.edge("C", "C1")
net.edge("C", "C2")
net.edge("C", "C3")
net.edge("C", "C4")

net.edge("D", "D1")
net.edge("D", "D2")
net.edge("D", "D3")
net.edge("D", "D4")

net.edge("E", "E1")
net.edge("E", "E2")
net.edge("E", "E3")
net.edge("E", "E4")

display(net)

"""Zauważmy jednak, że w wyniku działania kodu wygenerowała się czytelna sieć semantyczna. Wadą tego podejścia jest niestety bardzo szeroki wykres, który przy bardziej rozbudowanych sieciach semantycznych spowoduje konieczność przewijania podglądu. Możemy zmodyfikować kod w taki sposób aby powstał bardziej skupiony wykres, pozwalający na wykorzystanie większej powierzchni kartki. Interesuje nas również umieszczenie głównego obiektu w środku diagramu sieci semantycznej."""

from graphviz import Digraph
from IPython.display import display

# Tworzenie sieci semantycznej dla gołębia
net = Digraph()
net.attr(layout="neato", overlap="false", splines="true")

# Dodanie głównego węzła
net.node("A", "Gołąb", shape="circle", style="filled", fillcolor="lightblue")

# Dodanie grup cech, rozmieszczonych wokół głównego węzła
categories = {
    "B": "Cechy",
    "C": "Zachowanie",
    "D": "Środowisko",
    "E": "Znaczenie dla ludzi"
}
for key, value in categories.items():
    net.node(key, value, shape="ellipse", style="filled", fillcolor="lightgray")
    net.edge("A", key)

# Cechy gołębia
features = ["Ptak", "Latający", "Pióra", "Dziób", "Szare ubarwienie"]
for i, feature in enumerate(features, 1):
    net.node(f"B{i}", feature)
    net.edge("B", f"B{i}")

# Zachowanie
behaviors = ["Żerowanie", "Gromadzenie się w stada", "Orientacja w przestrzeni", "Budowanie gniazd"]
for i, behavior in enumerate(behaviors, 1):
    net.node(f"C{i}", behavior)
    net.edge("C", f"C{i}")

# Środowisko
environments = ["Miejskie", "Wiejskie", "Skalne klify", "Parki i place"]
for i, environment in enumerate(environments, 1):
    net.node(f"D{i}", environment)
    net.edge("D", f"D{i}")

# Znaczenie dla ludzi
importance = ["Symbol pokoju", "Gołębie pocztowe", "Obiekt badań naukowych", "Problem w miastach"]
for i, item in enumerate(importance, 1):
    net.node(f"E{i}", item)
    net.edge("E", f"E{i}")

# Wyświetlenie sieci
display(net)

"""4 Zadania 1. Zadanie ”Diagnoza problemów z urządzeniem”. Wejście: Cztery parametry (boolean) określające stan urządzenia:"""

from graphviz import Digraph
from IPython.display import display

# Parametry formularza do zbierania danych wejściowych od użytkownika
zasilanie = True    # @param {type:"boolean"}
ekran = True      # @param {type:"boolean"}
dzwiek = True     # @param {type:"boolean"}
klawiatura = True  # @param {type:"boolean"}

# Funkcja do diagnozy na podstawie reguł
def diagnoza(zasilanie, ekran, dzwiek, klawiatura):
    wynik = 'Brak diagnozy'
    # Baza wiedzy: Reguły diagnozy oparte na parametrach urządzenia
    reguly = [
        {'warunek': lambda z, e, d, k: not z, 'dzialanie': 'Brak zasilania'},
        {'warunek': lambda z, e, d, k: z and not e, 'dzialanie': 'Uszkodzony ekran'},
        {'warunek': lambda z, e, d, k: z and e and not d, 'dzialanie': 'Brak dźwięku'},
        {'warunek': lambda z, e, d, k: z and e and d and not k, 'dzialanie': 'Brak reakcji klawiatury'},
        {'warunek': lambda z, e, d, k: z and e and d and k, 'dzialanie': 'Urządzenie działa poprawnie'}
    ]
    # Dopasowanie do reguł
    for regula in reguly:
        if regula['warunek'](zasilanie, ekran, dzwiek, klawiatura):
            wynik = regula['dzialanie']
            break
    return wynik

# Funkcja do przetwarzania wyników diagnozy
def przetworz_wyniki():
    wynik_diag = diagnoza(zasilanie, ekran, dzwiek, klawiatura)
    print(f"Na podstawie wprowadzonych parametrów, diagnoza: {wynik_diag}")

# Funkcja tworząca drzewo decyzyjne
def create_decision_tree():
    tree = Digraph("DrzewoDecyzyjne", format="png")
    tree.attr("node", shape="box", style="filled", fillcolor="lightyellow")

    # Pierwsze pytanie: czy urządzenie ma zasilanie?
    tree.node("1", "Czy urządzenie ma zasilanie?")
    tree.node("1a", "Brak zasilania")
    tree.edge("1", "1a", label="Nie")

    # Jeśli ma zasilanie, pytamy o ekran
    tree.node("2", "Czy ekran działa?")
    tree.edge("1", "2", label="Tak")
    tree.node("2a", "Uszkodzony ekran")
    tree.edge("2", "2a", label="Nie")

    # Jeśli ekran działa, sprawdzamy dźwięk
    tree.node("3", "Czy dźwięk działa?")
    tree.edge("2", "3", label="Tak")
    tree.node("3a", "Brak dźwięku")
    tree.edge("3", "3a", label="Nie")

    # Jeśli dźwięk działa, sprawdzamy klawiaturę
    tree.node("4", "Czy klawiatura działa?")
    tree.edge("3", "4", label="Tak")
    tree.node("4a", "Brak reakcji klawiatury")
    tree.edge("4", "4a", label="Nie")

    # Jeśli wszystkie funkcje działają
    tree.node("4b", "Urządzenie działa poprawnie")
    tree.edge("4", "4b", label="Tak")

    return tree

# Uruchomienie procesu
if __name__ == "__main__":
    przetworz_wyniki()
    drzewo = create_decision_tree()
    display(drzewo)

""". Zadanie ”Ocena przygotowania samochodu do jazdy”. Wejście: Cztery parametry (boolean) określające stan samochodu:"""

from graphviz import Digraph
from IPython.display import display


silnik   = True   # @param {type:"boolean"}
opony    = True   # @param {type:"boolean"}
paliwo   = True   # @param {type:"boolean"}
swiatla  = False   # @param {type:"boolean"}

# Funkcja do diagnozy stanu samochodu na podstawie ustalonych reguł
def diagnoza(silnik, opony, paliwo, swiatla):
    # Pierwsza reguła: jeśli silnik nie działa, rozróżniamy przyczynę
    if not silnik:
        # Jeśli mimo braku działania silnika paliwo jest dostępne, przyjmujemy,
        # że problem wynika z uszkodzonego silnika
        if paliwo:
            return "Uszkodzony silnik"
        # Jeśli paliwa też nie ma, diagnoza to: Brak zasilania
        else:
            return "Brak zasilania"
    # Druga reguła: sprawdzamy działanie świateł
    elif not swiatla:
        return "Brak świateł, sprawdź oświetlenie"
    # Trzecia reguła: jeśli brakuje paliwa
    elif not paliwo:
        return "Brak paliwa"
    # Czwarta reguła: jeśli opony są zużyte (czyli parametr opony == False)
    elif not opony:
        return "Zużyte opony"
    # Jeśli wszystkie funkcje działają, samochód jest gotowy do jazdy
    else:
        return "Samochód gotowy do jazdy"

# Funkcja do przetwarzania wyników diagnozy
def przetworz_wyniki():
    wynik_diag = diagnoza(silnik, opony, paliwo, swiatla)
    print(f"Na podstawie wprowadzonych parametrów, diagnoza: {wynik_diag}")

# Funkcja tworząca drzewo decyzyjne ilustrujące proces diagnozy
def create_decision_tree():
    tree = Digraph("DrzewoDecyzyjne", format="png")
    tree.attr("node", shape="box", style="filled", fillcolor="lightyellow")

    # 1. Czy silnik działa?
    tree.node("1", "Czy silnik działa?")
    # Jeśli silnik NIE działa, sprawdzamy paliwo, aby rozróżnić przyczynę
    tree.node("1a", "Czy paliwo jest dostępne?")
    tree.edge("1", "1a", label="Nie")
    # Gdy paliwo jest dostępne -> uszkodzony silnik
    tree.node("1a1", "Uszkodzony silnik")
    tree.edge("1a", "1a1", label="Tak")
    # Gdy paliwa brak -> brak zasilania
    tree.node("1a2", "Brak zasilania")
    tree.edge("1a", "1a2", label="Nie")

    # Jeśli silnik działa, pytamy o światła
    tree.node("2", "Czy światła działają?")
    tree.edge("1", "2", label="Tak")
    tree.node("2a", "Brak świateł,\nsprawdź oświetlenie")
    tree.edge("2", "2a", label="Nie")

    # Jeśli światła działają, pytamy o paliwo
    tree.node("3", "Czy jest paliwo?")
    tree.edge("2", "3", label="Tak")
    tree.node("3a", "Brak paliwa")
    tree.edge("3", "3a", label="Nie")

    # Jeśli paliwo jest, pytamy o stan opon
    tree.node("4", "Czy opony są w dobrym stanie?")
    tree.edge("3", "4", label="Tak")
    tree.node("4a", "Zużyte opony")
    tree.edge("4", "4a", label="Nie")

    # Jeśli wszystkie funkcje działają, samochód jest gotowy do jazdy
    tree.node("4b", "Samochód gotowy do jazdy")
    tree.edge("4", "4b", label="Tak")

    return tree

# Uruchomienie procesu diagnozy i wyświetlenie drzewa decyzyjnego
if __name__ == "__main__":
    przetworz_wyniki()
    drzewo = create_decision_tree()
    display(drzewo)



from graphviz import Digraph
from IPython.display import display

# Tworzenie sieci semantycznej dla komputera
net = Digraph("Komputer_Semantic_Network", format="png")
net.attr(layout="neato", overlap="false", splines="true")

# Dodanie głównego węzła: Komputer
net.node("A", "Komputer", shape="circle", style="filled", fillcolor="lightblue")

# Dodanie kategorii wokół głównego węzła
categories = {
    "B": "Cechy",
    "C": "Funkcje",
    "D": "Środowisko",
    "E": "Znaczenie"
}
for key, value in categories.items():
    net.node(key, value, shape="ellipse", style="filled", fillcolor="lightgray")
    net.edge("A", key)

# Podkategoria: Cechy (właściwości techniczne)
features = ["Procesor", "Pamięć RAM", "Dysk twardy/SSD", "Karta graficzna", "Porty I/O"]
for i, feature in enumerate(features, start=1):
    node_id = f"B{i}"
    net.node(node_id, feature)
    net.edge("B", node_id)

# Podkategoria: Funkcje (zastosowania komputera)
functions = ["Przetwarzanie danych", "Obsługa oprogramowania", "Komunikacja", "Multimedia"]
for i, function in enumerate(functions, start=1):
    node_id = f"C{i}"
    net.node(node_id, function)
    net.edge("C", node_id)

# Podkategoria: Środowisko (miejsca użycia komputera)
environments = ["Dom", "Biuro", "Szkoła", "Przemysł", "Laboratorium"]
for i, environment in enumerate(environments, start=1):
    node_id = f"D{i}"
    net.node(node_id, environment)
    net.edge("D", node_id)

# Podkategoria: Znaczenie (dlaczego komputer jest ważny dla użytkowników)
meanings = ["Edukacja", "Praca", "Rozrywka", "Badania", "Komunikacja"]
for i, meaning in enumerate(meanings, start=1):
    node_id = f"E{i}"
    net.node(node_id, meaning)
    net.edge("E", node_id)

# Wyświetlenie diagramu
display(net)