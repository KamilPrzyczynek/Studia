# -*- coding: utf-8 -*-
"""lab05Inz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mHsIBPARzo0RFLcfNcESIaQ1LDl07qaY
"""

import pandas as pd
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

url = "https://raw.githubusercontent.com/prasertcbs/basic-dataset/refs/heads/master/groceries%20-%20groceries.csv"
df = pd.read_csv(url, header=None)
transactions = df.apply(lambda row: row.dropna().tolist(), axis=1).tolist()
te = TransactionEncoder()
te_ary = te.fit(transactions).transform(transactions)
df_encoded = pd.DataFrame(te_ary, columns=te.columns_)

frequent_itemsets = apriori(df_encoded, min_support=0.01, use_colnames=True)
rules = association_rules(frequent_itemsets, metric="lift", min_threshold=1)
rules_sorted = rules.sort_values(by="lift", ascending=False)
rules_sorted.head(10)

plt.figure(figsize=(10, 6))
sns.scatterplot(x="lift", y="confidence", data=rules_sorted)
plt.title("Lift vs. Confidence")
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x="support", y="confidence", data=rules_sorted)
plt.title("Support vs. Confidence")
plt.show()

rules["rule"] = rules["antecedents"].apply(lambda a: ", ".join(list(a))) + " -> " + rules["consequents"].apply(lambda c: ", ".join(list(c)))
fig_lift_conf = px.scatter(rules, x="lift", y="confidence", hover_data=["rule"], title="Lift vs. Confidence")
fig_lift_conf.show()
fig_supp_conf = px.scatter(rules, x="support", y="confidence", hover_data=["rule"], title="Support vs. Confidence")
fig_supp_conf.show()

"""2. Zwykresów interaktywnych odczytaj dwie reguły które mają Przyrost powyżej 3 oraz Ufność powyżej 0,5. Podaj te reguły i zinterpretuj ich wynik."""

filtered_rules = rules[(rules["lift"] > 3) & (rules["confidence"] > 0.5)]
filtered_rules[["antecedents", "consequents", "support", "confidence", "lift", "rule"]].sort_values(by="lift", ascending=False).head(2)

"""3. Co oznacza wartość Przyrostu w okolicach wartości 1?
Lift  1 brak istotnej zależności między produktami

lift = 1: kupowanie antecedentu nie wpływa na prawdopodobieństwo zakupu consequentu
lift > 1: kupowanie jednego produktu zwiększa szansę na zakup drugiego.
lift < 1: kupowanie jednego produktu zmniejsza szansę na zakup drugiego
"""

neutral_lift_rules = rules[(rules["lift"] >= 0.95) & (rules["lift"] <= 1.05)]
neutral_lift_rules = neutral_lift_rules[["antecedents", "consequents", "support", "confidence", "lift"]].sort_values(by="lift")
print("Reguły z lift ~1 (produkty niezależne od siebie):")
print(neutral_lift_rules.head(5))

"""Wysoki lift oznacza, że jeśli dojdzie do współwystąpienia produktów, to jest ono silniejsze niż przypadkowe.

Niska confidence oznacza, że reguła rzadko się sprawdza, czyli mimo że zależność jest silna — nie zachodzi często.
"""

high_lift_low_confidence = rules[(rules["lift"] > 3) & (rules["confidence"] < 0.2)]
high_lift_low_confidence = high_lift_low_confidence[["antecedents", "consequents", "support", "confidence", "lift"]].sort_values(by="lift", ascending=False)
print("\nReguły z wysokim lift (>3) i niską confidence (<0.2):")
print(high_lift_low_confidence.head(5))

"""5. Jaką odnotowano najwyższą wartość Wsparcia? Z czego wynika fakt, że wartości Wsparcia są generalnie bardzo niskie w tym zbiorze danych?"""

max_support = rules["support"].max()
print(f"\nNajwyższa wartość wsparcia: {max_support:.4f}")

"""Zbiór zawiera prawie 10 000 transakcji i bardzo wiele różnych produktów.
Klienci kupują różne kombinacje produktów – brak jednego, dominującego schematu zakupowego.
Koszyki zakupowe są zwykle krótkie (np. 2–5 produktów), co ogranicza liczbę powtarzających się układów.
Wiele produktów jest kupowanych rzadko, co wpływa na niską częstotliwość ich współwystępowania z innymi.

6. Czy mogą istnieć reguły które po prawej lub po lewej stronie mają więcej niż jeden produkt?
"""

multi_item_rules = rules[(rules["antecedents"].apply(len) > 1) | (rules["consequents"].apply(len) > 1)]
print("\nReguły z więcej niż jednym produktem po lewej lub prawej stronie:")
print(multi_item_rules[["antecedents", "consequents", "support", "confidence", "lift"]].head())

"""7. Porównaj kilka reguł, które “leżą” na identycznej wartości osi Przyrostu. Czy te reguły są symetryczne? Jeśli tak to wyjaśnij dlaczego mają rożne wartości Wsparcia."""

rounded_rules = rules.copy()
rounded_rules["rounded_lift"] = rounded_rules["lift"].round(2)


duplicates = rounded_rules.groupby("rounded_lift").filter(lambda x: len(x) > 1)


print("\nReguły z identycznym lub bardzo podobnym lift:")
print(duplicates[["antecedents", "consequents", "support", "confidence", "lift"]].head(10))